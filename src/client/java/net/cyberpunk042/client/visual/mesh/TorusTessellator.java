package net.cyberpunk042.client.visual.mesh;

import net.cyberpunk042.client.visual.animation.WaveDeformer;
import net.cyberpunk042.log.Logging;
import net.cyberpunk042.visual.animation.WaveConfig;
import net.cyberpunk042.visual.pattern.QuadPattern;
import net.cyberpunk042.visual.pattern.VertexPattern;
import net.cyberpunk042.visual.shape.TorusShape;
import net.cyberpunk042.visual.visibility.VisibilityMask;

/**
 * Tessellates torus (donut) shapes into triangle meshes.
 * 
 * <h2>Geometry</h2>
 * <p>A torus is generated by rotating a circle around an axis. The circle
 * has radius {@code minorRadius} and is centered at distance {@code majorRadius}
 * from the axis.</p>
 * 
 * <h2>Parametric Equations</h2>
 * <pre>
 * x = (R + r * cos(v)) * cos(u)
 * y = r * sin(v)
 * z = (R + r * cos(v)) * sin(u)
 * 
 * where R = majorRadius, r = minorRadius
 * u = angle around the ring (0 to 2π)
 * v = angle around the tube cross-section (0 to 2π)
 * </pre>
 * 
 * @see TorusShape
 */
public final class TorusTessellator {
    
    private TorusTessellator() {}
    
    /**
     * Tessellates a torus shape into a mesh with optional wave deformation.
     * 
     * @param shape The torus shape definition
     * @param pattern Optional vertex pattern (can be null)
     * @param visibility Optional visibility mask (can be null)
     * @param wave Wave configuration for CPU deformation (null = no wave)
     * @param time Current time for wave animation
     * @return Generated mesh
     */
    public static Mesh tessellate(TorusShape shape, VertexPattern pattern,
                                   VisibilityMask visibility,
                                   WaveConfig wave, float time) {
        if (shape == null) {
            throw new IllegalArgumentException("TorusShape cannot be null");
        }
        
        if (pattern == null) {
            pattern = QuadPattern.FILLED_1;
        }
        
        Logging.RENDER.topic("tessellate")
            .kv("shape", "torus")
            .kv("majorR", shape.majorRadius())
            .kv("minorR", shape.minorRadius())
            .kv("majorSeg", shape.majorSegments())
            .kv("minorSeg", shape.minorSegments())
            .kv("wave", wave != null && wave.isActive())
            .debug("Tessellating torus");
        
        MeshBuilder builder = MeshBuilder.triangles();
        
        float R = shape.majorRadius();
        float r = shape.minorRadius();
        int majorSegs = shape.majorSegments();
        int minorSegs = shape.minorSegments();
        float arcStart = GeometryMath.toRadians(shape.arcStart());
        float arcEnd = GeometryMath.toRadians(shape.arcEnd());
        float arcRange = arcEnd - arcStart;
        
        boolean applyWave = wave != null && wave.isActive() && wave.isCpuMode();
        
        // Generate vertices
        int[][] vertexIndices = new int[majorSegs + 1][minorSegs + 1];
        
        for (int i = 0; i <= majorSegs; i++) {
            float u = arcStart + (i / (float) majorSegs) * arcRange;
            float cosU = (float) Math.cos(u);
            float sinU = (float) Math.sin(u);
            
            for (int j = 0; j <= minorSegs; j++) {
                float vAngle = GeometryMath.TWO_PI * j / minorSegs;
                float cosV = (float) Math.cos(vAngle);
                float sinV = (float) Math.sin(vAngle);
                
                // Position
                float x = (R + r * cosV) * cosU;
                float y = r * sinV;
                float z = (R + r * cosV) * sinU;
                
                // Normal (points outward from tube surface)
                float nx = cosV * cosU;
                float ny = sinV;
                float nz = cosV * sinU;
                
                // UV coordinates
                float texU = i / (float) majorSegs;
                float texV = j / (float) minorSegs;
                
                Vertex vtx = new Vertex(x, y, z, nx, ny, nz, texU, texV, 1.0f);
                
                // Apply wave deformation
                if (applyWave) {
                    vtx = WaveDeformer.applyToVertex(vtx, wave, time);
                }
                
                vertexIndices[i][j] = builder.addVertex(vtx);
            }
        }
        
        // Generate quads (as two triangles each)
        for (int i = 0; i < majorSegs; i++) {
            float uFrac = i / (float) majorSegs;
            
            for (int j = 0; j < minorSegs; j++) {
                float vFrac = j / (float) minorSegs;
                
                // Check visibility (using u as latitude, v as longitude conceptually)
                if (visibility != null && !visibility.isVisible(vFrac, uFrac)) {
                    continue;
                }
                
                // Check pattern
                if (!pattern.shouldRender(i * minorSegs + j, majorSegs * minorSegs)) {
                    continue;
                }
                
                // Quad indices mapped to sphere naming:
                //   topLeft     = [i][j], topRight = [i+1][j]
                //   bottomLeft  = [i][j+1], bottomRight = [i+1][j+1]
                int topLeft     = vertexIndices[i][j];
                int topRight    = vertexIndices[i + 1][j];
                int bottomLeft  = vertexIndices[i][j + 1];
                int bottomRight = vertexIndices[i + 1][j + 1];
                
                // Use quadAsTrianglesFromPattern for pattern support
                builder.quadAsTrianglesFromPattern(topLeft, topRight, bottomRight, bottomLeft, pattern);
            }
        }
        
        Logging.RENDER.topic("tessellate")
            .kv("vertices", builder.vertexCount())
            .trace("Torus tessellation complete");
        
        return builder.build();
    }
    
    /**
     * Tessellates a torus shape into a mesh (backward compatible).
     */
    public static Mesh tessellate(TorusShape shape, VertexPattern pattern,
                                   VisibilityMask visibility) {
        return tessellate(shape, pattern, visibility, null, 0);
    }
    
    public static Mesh tessellate(TorusShape shape) {
        return tessellate(shape, null, null, null, 0);
    }
}


