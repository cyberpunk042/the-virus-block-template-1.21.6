package net.cyberpunk042.client.visual.mesh;

import net.cyberpunk042.log.Logging;
import net.cyberpunk042.visual.pattern.QuadPattern;
import net.cyberpunk042.visual.pattern.VertexPattern;
import net.cyberpunk042.visual.shape.TorusShape;
import net.cyberpunk042.visual.visibility.VisibilityMask;

/**
 * Tessellates torus (donut) shapes into triangle meshes.
 * 
 * <h2>Geometry</h2>
 * <p>A torus is generated by rotating a circle around an axis. The circle
 * has radius {@code minorRadius} and is centered at distance {@code majorRadius}
 * from the axis.</p>
 * 
 * <h2>Parametric Equations</h2>
 * <pre>
 * x = (R + r * cos(v)) * cos(u)
 * y = r * sin(v)
 * z = (R + r * cos(v)) * sin(u)
 * 
 * where R = majorRadius, r = minorRadius
 * u = angle around the ring (0 to 2π)
 * v = angle around the tube cross-section (0 to 2π)
 * </pre>
 * 
 * @see TorusShape
 */
public final class TorusTessellator {
    
    private TorusTessellator() {}
    
    /**
     * Tessellates a torus shape into a mesh.
     * 
     * @param shape The torus shape definition
     * @param pattern Optional vertex pattern (can be null)
     * @param visibility Optional visibility mask (can be null)
     * @return Generated mesh
     */
    public static Mesh tessellate(TorusShape shape, VertexPattern pattern,
                                   VisibilityMask visibility) {
        if (shape == null) {
            throw new IllegalArgumentException("TorusShape cannot be null");
        }
        
        if (pattern == null) {
            pattern = QuadPattern.FILLED_1;
        }
        
        Logging.RENDER.topic("tessellate")
            .kv("shape", "torus")
            .kv("majorR", shape.majorRadius())
            .kv("minorR", shape.minorRadius())
            .kv("majorSeg", shape.majorSegments())
            .kv("minorSeg", shape.minorSegments())
            .debug("Tessellating torus");
        
        MeshBuilder builder = MeshBuilder.triangles();
        
        float R = shape.majorRadius();
        float r = shape.minorRadius();
        int majorSegs = shape.majorSegments();
        int minorSegs = shape.minorSegments();
        float arcStart = GeometryMath.toRadians(shape.arcStart());
        float arcEnd = GeometryMath.toRadians(shape.arcEnd());
        float arcRange = arcEnd - arcStart;
        
        // Generate vertices
        int[][] vertexIndices = new int[majorSegs + 1][minorSegs + 1];
        
        for (int i = 0; i <= majorSegs; i++) {
            float u = arcStart + (i / (float) majorSegs) * arcRange;
            float cosU = (float) Math.cos(u);
            float sinU = (float) Math.sin(u);
            
            for (int j = 0; j <= minorSegs; j++) {
                float v = GeometryMath.TWO_PI * j / minorSegs;
                float cosV = (float) Math.cos(v);
                float sinV = (float) Math.sin(v);
                
                // Position
                float x = (R + r * cosV) * cosU;
                float y = r * sinV;
                float z = (R + r * cosV) * sinU;
                
                // Normal (points outward from tube surface)
                float nx = cosV * cosU;
                float ny = sinV;
                float nz = cosV * sinU;
                
                // UV coordinates
                float texU = i / (float) majorSegs;
                float texV = j / (float) minorSegs;
                
                vertexIndices[i][j] = builder.addVertex(
                    new Vertex(x, y, z, nx, ny, nz, texU, texV));
            }
        }
        
        // Generate quads (as two triangles each)
        for (int i = 0; i < majorSegs; i++) {
            float uFrac = i / (float) majorSegs;
            
            for (int j = 0; j < minorSegs; j++) {
                float vFrac = j / (float) minorSegs;
                
                // Check visibility (using u as latitude, v as longitude conceptually)
                if (visibility != null && !visibility.isVisible(vFrac, uFrac)) {
                    continue;
                }
                
                // Check pattern
                if (!pattern.shouldRender(i * minorSegs + j, majorSegs * minorSegs)) {
                    continue;
                }
                
                // Quad vertices
                int i0 = vertexIndices[i][j];
                int i1 = vertexIndices[i + 1][j];
                int i2 = vertexIndices[i + 1][j + 1];
                int i3 = vertexIndices[i][j + 1];
                
                // Two triangles per quad
                builder.triangle(i0, i1, i2);
                builder.triangle(i0, i2, i3);
            }
        }
        
        Logging.RENDER.topic("tessellate")
            .kv("vertices", builder.vertexCount())
            .trace("Torus tessellation complete");
        
        return builder.build();
    }
    
    public static Mesh tessellate(TorusShape shape) {
        return tessellate(shape, null, null);
    }
}


