package net.cyberpunk042.client.gui.screen;

import net.cyberpunk042.client.gui.component.*;
import net.cyberpunk042.client.gui.layout.*;
import net.cyberpunk042.client.gui.panel.*;
import net.cyberpunk042.client.gui.panel.sub.*;
import net.cyberpunk042.client.gui.preview.FieldPreviewRenderer;
import net.cyberpunk042.client.gui.render.SimplifiedFieldRenderer;
import net.cyberpunk042.client.gui.state.FieldEditState;
import net.cyberpunk042.client.gui.state.FieldEditStateHolder;
import net.cyberpunk042.field.FieldLayer;
import net.cyberpunk042.client.gui.widget.*;
import net.cyberpunk042.client.gui.util.PresetRegistry;
import net.cyberpunk042.client.gui.util.FragmentRegistry;
import net.cyberpunk042.client.gui.util.GuiConfigPersistence;
import net.cyberpunk042.client.gui.util.WidgetVisibility;
import net.cyberpunk042.client.network.GuiPacketSender;
import net.cyberpunk042.log.Logging;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;

import java.util.ArrayList;
import java.util.List;

/**
 * G01: Main Field Customizer GUI screen with 2×2 grid layout.
 * 
 * <pre>
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │ [⬜] Field Customizer                                            [×]    │
 * ├─────────────────────────────────────────────────────────────────────────┤
 * │ [Quick] [Advanced] [Debug] [Profiles]                                   │
 * ├─────────────────────────────┬───────────────────────────────────────────┤
 * │                             │ LAYER: [+] ◀ base ▶ [+]                   │
 * │       3D PREVIEW            │ PRIM:  [◀] sphere_main [+]                │
 * │                             ├───────────────────────────────────────────┤
 * │                             │ [Fill] [Appear] [Visibility] ← Quick      │
 * │                             │ [Anim] [Trans] [Pred] [Orbit] ← Advanced  │
 * ├─────────────────────────────┼───────────────────────────────────────────┤
 * │       SHAPE                 │                                           │
 * │   Type: [Sphere ▼]          │   (sub-tab content continues)             │
 * │   Algo: [ICO ▼]             │                                           │
 * └─────────────────────────────┴───────────────────────────────────────────┘
 * </pre>
 */
public class FieldCustomizerScreen extends Screen {
    
    private static final int TITLE_HEIGHT = 20;
    private static final int TAB_BAR_HEIGHT = 22;
    private static final int STATUS_HEIGHT = 18;
    private static final int MARGIN = 8;
    private static final int SELECTOR_HEIGHT = 22;
    
    private final FieldEditState state;
    private GuiMode mode;  // Loaded from config or default to FULLSCREEN
    
    // ─────────────────────────────────────────────────────────────────────────────
    // Config Persistence (delegated to GuiConfigPersistence)
    // ─────────────────────────────────────────────────────────────────────────────
    
    private static GuiMode loadSavedMode() {
        return GuiConfigPersistence.loadSavedMode();
    }
    
    private static void saveMode(GuiMode mode) {
        GuiConfigPersistence.saveMode(mode);
    }
    
    // Layout (calculated bounds - no more grid field, layout handles everything)
    
    // Tab state
    private TabType currentTab = TabType.QUICK;
    private DropdownWidget<String> presetDropdown;  // Reference for overlay rendering
    private net.minecraft.client.gui.widget.CyclingButtonWidget<Boolean> previewModeCheckbox;
    private boolean useFullPreviewRenderer = false;
    private PresetConfirmDialog presetConfirmDialog;
    
    // Config flags
    private static boolean backgroundBlurEnabled = true;
    
    // Shape panel
    private ShapeSubPanel shapePanel;
    private Bounds shapePanelBounds;
    
    // Profiles panel
    private ProfilesPanel profilesPanel;
    private Bounds profilesLeftBounds;
    private Bounds profilesRightBounds;
    
    // Status bar
    private StatusBar statusBar;
    
    // Modal dialog
    private ModalDialog activeModal;
    
    // ─────────────────────────────────────────────────────────────────────────────
    // NEW COMPONENT-BASED ARCHITECTURE (Phases 4-10)
    // ─────────────────────────────────────────────────────────────────────────────
    
    // Visibility controller for mode-based UI visibility
    private VisibilityController visibilityController;
    
    // Content provider factory for sub-tab panels
    private ContentProviderFactory contentFactory;
    
    // Layout strategy (handles bounds calculation and rendering)
    private LayoutManager layout;
    
    // UI Components (replace inline widget creation)
    private HeaderBar headerBar;
    private TabBar tabBar;
    private SelectorBar selectorBar;
    private ContentArea contentArea;
    
    public FieldCustomizerScreen() {
        this(FieldEditStateHolder.getOrCreate());  // Preserve state on reopen
    }
    
    public FieldCustomizerScreen(FieldEditState state) {
        super(Text.literal("Field Customizer"));
        this.state = state;
        this.mode = loadSavedMode();  // Restore last mode
        Logging.GUI.topic("screen").info("FieldCustomizerScreen created, mode={}", mode);
    }
    
    // State change listener for preview refresh
    private Runnable stateChangeListener;
    
    @Override
    protected void init() {
        super.init();
        
        // Reload fragments/presets on open to pick up config files
        FragmentRegistry.reload();
        PresetRegistry.reset();
        net.cyberpunk042.client.gui.state.FieldEditStateHolder.set(state);
        
        // Register state change listener (only once)
        if (stateChangeListener == null) {
            stateChangeListener = this::onStateChanged;
            state.addChangeListener(stateChangeListener);
        }
        
        // Initialize component infrastructure
        visibilityController = new VisibilityController(state, mode);
        contentFactory = new ContentProviderFactory(this, state, textRenderer, this::registerWidgets);
        WidgetVisibility.clearAll();
        
        // Create layout strategy based on mode
        layout = mode == GuiMode.FULLSCREEN ? new FullscreenLayout() : new WindowedLayout();
        layout.calculate(width, height);
        
        // Unified component initialization
        initComponents();
        
        Logging.GUI.topic("screen").debug("FieldCustomizerScreen initialized in {} mode", mode);
    }
    
    /** Unified initialization for both modes - all UI created via components */
    private void initComponents() {
        // Header bar
        headerBar = new HeaderBar(textRenderer, this::toggleMode, this::resetState, this::close,
            FieldEditStateHolder::isTestFieldActive, state::isDirty, () -> mode);
        headerBar.setBounds(layout.getTitleBarBounds());
        
        // Tab bar
        tabBar = new TabBar(textRenderer, visibilityController, this::switchTab, 
            this::onPresetSelected, this::refreshTabsForRendererMode);
        tabBar.setBounds(layout.getTabBarBounds());
        tabBar.setActiveTab(currentTab);
        presetDropdown = tabBar.getPresetDropdown();
        
        // Selector bar (layout provides correct bounds for both modes)
        selectorBar = new SelectorBar(textRenderer, this::getLayerNames, this::getPrimitiveNames,
            state::getSelectedLayerIndex, state::getSelectedPrimitiveIndex,
            this::onLayerSelected, this::onPrimitiveSelected, this::showLayerModal, this::showPrimitiveModal,
            this::onLayerAdd, this::onPrimitiveAdd);
        selectorBar.setBounds(layout.getSelectorBounds());
        
        // Content area (sub-tabs)
        initContentArea();
        
        // Shape panel
        initShapePanel();
        
        // Profiles panel
        initProfilesPanel();
        
        // Status bar
        statusBar = new StatusBar(state, textRenderer);
        statusBar.setBounds(layout.getStatusBarBounds());
        
        // Preview checkbox (fullscreen only)
        previewModeCheckbox = (mode == GuiMode.FULLSCREEN) ? createPreviewModeCheckbox() : null;
        
        registerWidgets();
    }
    
    /** Creates/updates the ContentArea for current selection */
    private void initContentArea() {
        contentArea = new ContentArea(textRenderer, visibilityController, contentFactory, this::refreshSubTabWidgets);
        contentArea.setBounds(layout.getContentBounds());
        contentArea.setActiveMainTab(currentTab);
    }
    
    /**
     * Called when FieldEditState changes. Refreshes preview and optionally syncs to server.
     */
    private void onStateChanged() {
        // Mark SimplifiedFieldRenderer as dirty for world preview
        SimplifiedFieldRenderer.markDirty();
        
        // If live preview is enabled, sync to server
        if (state.getBool("livePreviewEnabled")) {
            GuiPacketSender.updateDebugField(state.toStateJson());
        }
        
        Logging.GUI.topic("state").trace("State changed, preview refreshed");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // CALLBACKS
    // ═══════════════════════════════════════════════════════════════════════════
    
    /**
     * Called when a preset is selected from the dropdown.
     * Shows confirmation dialog before applying.
     */
    private void onPresetSelected(String presetName) {
        if (presetName.equals("Select Preset…") || presetName.equals("No presets found")) {
            return;
        }
        
        // Show confirmation dialog
        presetConfirmDialog = new PresetConfirmDialog(presetName, confirmed -> {
            if (confirmed) {
                PresetRegistry.applyPreset(state, presetName);
                ToastNotification.success("Applied preset: " + presetName);
            }
            // Reset dropdown to placeholder after handling
            presetDropdown.setSelectedIndex(0);
        });
        presetConfirmDialog.show(width, height);
    }
    
    private void initShapePanel() {
        shapePanelBounds = layout.getShapePanelBounds();
        shapePanel = new ShapeSubPanel(this, state, 0);
        shapePanel.setWarningCallback((w, c) -> { if (statusBar != null) { if (w != null) statusBar.setWarning(w, c); else statusBar.clearWarning(); }});
        shapePanel.init(shapePanelBounds.width(), shapePanelBounds.height());
        shapePanel.setBoundsQuiet(shapePanelBounds);
        shapePanel.applyBoundsOffset();
    }
    
    private void initProfilesPanel() {
        profilesLeftBounds = layout.getProfilesLeftBounds();
        profilesRightBounds = layout.getProfilesRightBounds();
        profilesPanel = new ProfilesPanel(this, state);
        profilesPanel.setDualBounds(profilesLeftBounds, profilesRightBounds);
        profilesPanel.init(profilesLeftBounds.width(), profilesLeftBounds.height());
        if (mode == GuiMode.FULLSCREEN) profilesPanel.applyBoundsOffset();
    }
    
    private net.minecraft.client.gui.widget.CyclingButtonWidget<Boolean> createPreviewModeCheckbox() {
        if (!layout.hasPreviewWidget()) return null;
        Bounds previewBounds = layout.getPreviewBounds();
        int checkX = previewBounds.x() + 4, checkY = previewBounds.y() + 4;
        return net.minecraft.client.gui.widget.CyclingButtonWidget.<Boolean>builder(
                value -> Text.literal(value ? "☑ Full" : "☐ Fast"))
            .values(List.of(false, true)).initially(useFullPreviewRenderer)
            .tooltip(value -> net.minecraft.client.gui.tooltip.Tooltip.of(
                Text.literal(value ? "3D preview uses FieldRenderer (accurate)" : "3D preview uses SimplifiedFieldRenderer (fast)")))
            .omitKeyText()
            .build(checkX, checkY, 60, 12, Text.literal(""), (btn, value) -> useFullPreviewRenderer = value);
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // MODE & TAB SWITCHING
    // ═══════════════════════════════════════════════════════════════════════════
    
    private void toggleMode() {
        mode = mode.toggle();
        saveMode(mode);  // Persist preference
        // Reinitialize the entire screen for the new mode
        clearChildren();
        init();
        Logging.GUI.topic("screen").info("Toggled to {} mode", mode);
    }
    
    private void resetState() {
        // Reset the edit state to defaults
        state.reset();
        // Rebuild the UI to reflect the reset
        clearChildren();
        init();
        Logging.GUI.topic("screen").info("State reset to defaults");
        ToastNotification.info("Reset to defaults");
    }
    
    private void switchTab(TabType tab) {
        if (tab == TabType.DEBUG && !state.getBool("debugUnlocked")) {
            ToastNotification.warning("Debug mode requires operator access");
            return;
        }
        
        currentTab = tab;
        updateMainTabButtons();
        registerWidgets();
        
        Logging.GUI.topic("screen").debug("Switched to tab: {}", tab);
    }
    
    private void updateMainTabButtons() {
        if (tabBar != null) {
            tabBar.setActiveTab(currentTab);
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // WIDGET REGISTRATION
    // ═══════════════════════════════════════════════════════════════════════════
    
    private void registerWidgets() {
        clearChildren();
        
        // Header and Tab components
        if (headerBar != null) addWidgetsFrom(headerBar::getWidgets);
        if (tabBar != null) addWidgetsFrom(tabBar::getWidgets);
        addIfPresent(previewModeCheckbox);
        
        // Tab-specific content
        if (currentTab != TabType.PROFILES) {
            // Selectors
            if (selectorBar != null) addWidgetsFrom(selectorBar::getWidgets);
            
            // Sub-tabs via ContentArea
            if (contentArea != null && contentArea.isVisible()) {
                addWidgetsFrom(contentArea::getWidgets);
            }
            
            // Shape panel
            if (shapePanel != null) addWidgetsFrom(shapePanel::getWidgets);
        } else {
            if (profilesPanel != null) addWidgetsFrom(profilesPanel::getWidgets);
        }
        
        // Modal overlay
        if (activeModal != null && activeModal.isVisible()) {
            addWidgetsFrom(activeModal::getWidgets);
        }
    }
    
    /** Functional interface for getWidgets supplier */
    @FunctionalInterface
    private interface WidgetSource {
        java.util.List<? extends net.minecraft.client.gui.widget.ClickableWidget> getWidgets();
    }
    
    /** Helper to add widgets from a supplier */
    private void addWidgetsFrom(WidgetSource source) {
        for (var w : source.getWidgets()) addDrawableChild(w);
    }
    
    /** Helper to add a single widget if not null */
    private void addIfPresent(net.minecraft.client.gui.widget.ClickableWidget w) {
        if (w != null) addDrawableChild(w);
    }
    
    /**
     * Called when a sub-tab changes to re-register its widgets with the screen.
     */
    private void refreshSubTabWidgets() {
        // Just re-run full registration - it clears and re-adds all widgets
        registerWidgets();
    }
    
    /**
     * Refreshes all sub-tab panes when renderer mode changes.
     * This updates the enabled/disabled state of tabs based on feature support.
     */
    private void refreshTabsForRendererMode() {
        // Refresh TabBar visibility (hides/shows Advanced tab based on mode)
        if (tabBar != null) {
            tabBar.refreshVisibility();
        }
        
        // Refresh ContentArea (rebuilds sub-tabs for visibility changes)
        if (contentArea != null) {
            contentArea.refreshForRendererMode();
        }
        
        // Notify visibility controller to refresh mode-dependent widgets
        if (visibilityController != null) {
            visibilityController.notifyRendererModeChanged();
        }
        
        registerWidgets(); // Re-register to pick up button changes
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // MODALS
    // ═══════════════════════════════════════════════════════════════════════════
    
    private void showLayerModal(String layerName) {
        int idx = state.getSelectedLayerIndex();
        activeModal = ModalFactory.createLayerModal(state, layerName, idx, textRenderer, width, height,
            newName -> { state.renameLayer(idx, newName); refreshLayerSelector(); },
            () -> { state.removeLayer(idx); refreshLayerSelector(); 
                    if (selectorBar != null) selectorBar.selectLayerIndex(Math.max(0, idx - 1)); 
                    ToastNotification.info("Layer deleted"); },
            () -> { activeModal = null; registerWidgets(); });
        activeModal.show();
        registerWidgets();
        ModalFactory.focusTextField(activeModal, this);
    }
    
    private void showPrimitiveModal(String primName) {
        int layerIdx = state.getSelectedLayerIndex();
        int primIdx = state.getSelectedPrimitiveIndex();
        activeModal = ModalFactory.createPrimitiveModal(state, primName, layerIdx, primIdx, textRenderer, width, height,
            newName -> { state.renamePrimitive(layerIdx, primIdx, newName); refreshPrimitiveSelector(); },
            () -> { state.removePrimitive(layerIdx, primIdx); refreshPrimitiveSelector();
                    if (selectorBar != null) selectorBar.selectPrimitiveIndex(Math.max(0, primIdx - 1));
                    ToastNotification.info("Primitive deleted"); },
            () -> { activeModal = null; registerWidgets(); });
        activeModal.show();
        registerWidgets();
        ModalFactory.focusTextField(activeModal, this);
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // HELPERS
    // ═══════════════════════════════════════════════════════════════════════════
    
    private List<String> getLayerNames() {
        List<String> names = new ArrayList<>();
        for (FieldLayer layer : state.getFieldLayers()) {
            names.add(layer.id());
        }
        return names;
    }
    
    private List<String> getPrimitiveNames() {
        int layerIdx = state.getSelectedLayerIndex();
        return new ArrayList<>(state.getPrimitivesForLayer(layerIdx));
    }

    private void refreshLayerSelector() {
        if (selectorBar != null) {
            selectorBar.refreshLayers();
            registerWidgets();
        }
    }

    private void refreshPrimitiveSelector() {
        if (selectorBar != null) {
            selectorBar.refreshPrimitives();
            registerWidgets();
        }
    }
    
    // Selector callbacks
    private void onLayerSelected(String name) {
        int idx = getLayerNames().indexOf(name);
        state.setSelectedLayerIndex(idx);
        selectorBar.refreshPrimitives();
        initContentArea();
        registerWidgets();
    }
    
    private void onPrimitiveSelected(String name) {
        int idx = getPrimitiveNames().indexOf(name);
        state.setSelectedPrimitiveIndex(idx);
        initContentArea();
        registerWidgets();
    }
    
    private void onLayerAdd() {
        int newIdx = state.addLayer();
        state.setSelectedLayerIndex(newIdx);
        selectorBar.refreshLayers();
        selectorBar.selectLayerIndex(newIdx);
        selectorBar.refreshPrimitives();
        initContentArea();
        registerWidgets();
    }
    
    private void onPrimitiveAdd() {
        int newIdx = state.addPrimitive(state.getSelectedLayerIndex());
        state.setSelectedPrimitiveIndex(newIdx);
        selectorBar.refreshPrimitives();
        selectorBar.selectPrimitiveIndex(newIdx);
        initContentArea();
        registerWidgets();
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // TICK & RENDER
    // ═══════════════════════════════════════════════════════════════════════════
    
    /** Returns the SubTabPane for the current tab, or null if on Profiles. */
    private SubTabPane getCurrentSubTabs() {
        if (contentArea != null) {
            return contentArea.getActiveSubTabPane();
        }
        return null;
    }
    
    @Override
    public void tick() {
        super.tick();
        
        // ContentArea handles sub-tab ticking
        if (contentArea != null && contentArea.isVisible()) {
            contentArea.tick();
        } else {
            SubTabPane subTabs = getCurrentSubTabs();
            if (subTabs != null) subTabs.tick();
        }
        if (currentTab == TabType.PROFILES && profilesPanel != null) profilesPanel.tick();
        if (shapePanel != null) shapePanel.tick();
    }
    
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        if (mode == GuiMode.FULLSCREEN) {
            renderFullscreenMode(context, mouseX, mouseY, delta);
        } else {
            renderWindowedMode(context, mouseX, mouseY, delta);
        }
        
        // Widgets (buttons, etc.)
        super.render(context, mouseX, mouseY, delta);
        
        // Dropdown overlay (must be rendered after all other widgets for z-order)
        if (presetDropdown != null && presetDropdown.isExpanded()) {
            presetDropdown.renderOverlay(context, mouseX, mouseY);
        }
        
        // Modal overlay + re-render modal widgets on top of overlay
        if (activeModal != null && activeModal.isVisible()) {
            activeModal.render(context, mouseX, mouseY, delta);
            for (var w : activeModal.getWidgets()) {
                w.render(context, mouseX, mouseY, delta);
            }
        }
        
        // Preset confirmation dialog (on top of modals)
        if (presetConfirmDialog != null && presetConfirmDialog.isVisible()) {
            presetConfirmDialog.render(context, mouseX, mouseY, delta);
        }
        
        // Toasts
        ToastNotification.renderAll(context, textRenderer, width, height);
    }
    
    private void renderFullscreenMode(DrawContext context, int mouseX, int mouseY, float delta) {
        // Background and frame from layout
        layout.renderBackground(context, width, height);
        layout.renderFrame(context);
        
        // Fullscreen-specific: HeaderBar and 3D preview
        if (headerBar != null) headerBar.render(context, mouseX, mouseY, delta);
        renderQuadrantBackgrounds(context);
        if (grid != null) render3DPreview(context, grid.topLeft(), delta);
        
        // Common content rendering
        renderContentArea(context, mouseX, mouseY, delta);
        
        // Status bar
        statusBar.render(context, mouseX, mouseY, delta);
    }
    
    private void renderWindowedMode(DrawContext context, int mouseX, int mouseY, float delta) {
        // Background and frame from layout
        layout.renderBackground(context, width, height);
        layout.renderFrame(context);
        
        // Windowed-specific: panel titles
        Bounds leftTitle = ((WindowedLayout) layout).getLeftTitleBar();
        context.drawTextWithShadow(textRenderer, "⬡ Field", leftTitle.x() + 4, leftTitle.y() + 4, 0xFFAAFFAA);
        if (state.isDirty()) {
            context.drawText(textRenderer, "●", leftTitle.right() - 36, leftTitle.y() + 4, 0xFFFFAA00, false);
        }
        
        // Common content rendering
        renderContentArea(context, mouseX, mouseY, delta);
        
        // Windowed-specific: right panel title
        SubTabPane subTabs = getCurrentSubTabs();
        if (subTabs != null) {
            Bounds rightTitle = ((WindowedLayout) layout).getRightTitleBar();
            context.drawTextWithShadow(textRenderer, "Context", rightTitle.x() + 4, rightTitle.y() + 4, 0xFFAAFFAA);
        }
        
        // Status bar
        statusBar.render(context, mouseX, mouseY, delta);
    }
    
    /** Renders the shared content: selectors, sub-tabs or profiles, shape panel */
    private void renderContentArea(DrawContext context, int mouseX, int mouseY, float delta) {
        if (currentTab != TabType.PROFILES) {
            // Selectors
            if (selectorBar != null) selectorBar.render(context, mouseX, mouseY, delta);
            
            // Sub-tabs
            if (contentArea != null && contentArea.isVisible()) {
                contentArea.render(context, mouseX, mouseY, delta);
            }
            
            // Shape panel
            if (shapePanel != null) renderPanelInBounds(context, shapePanel, shapePanelBounds, mouseX, mouseY, delta);
        } else {
            // Profiles tab
            if (profilesPanel != null) profilesPanel.render(context, mouseX, mouseY, delta);
        }
    }
    
    private void renderQuadrantBackgrounds(DrawContext context) {
        // Top-left: Preview area
        Bounds tl = grid.topLeft();
        context.fill(tl.x(), tl.y(), tl.right(), tl.bottom(), 0xFF0a0a0a);
        context.drawBorder(tl.x(), tl.y(), tl.width(), tl.height(), 0xFF333333);
        
        // Bottom-left: Shape area
        Bounds bl = grid.bottomLeft();
        context.fill(bl.x(), bl.y(), bl.right(), bl.bottom(), 0xFF151515);
        context.drawBorder(bl.x(), bl.y(), bl.width(), bl.height(), 0xFF333333);
        
        // Right column background (both cells)
        Bounds rightCol = grid.rightColumn();
        context.fill(rightCol.x(), rightCol.y(), rightCol.right(), rightCol.bottom(), 0xFF121212);
    }
    
    /**
     * Renders a panel within its bounds with scissoring.
     * Widgets should already be positioned at their screen coordinates
     * (call panel.applyBoundsOffset() after init if needed).
     */
    private void renderPanelInBounds(DrawContext context, AbstractPanel panel, Bounds bounds, int mouseX, int mouseY, float delta) {
        if (panel == null || bounds == null) return;
        
        context.enableScissor(bounds.x(), bounds.y(), bounds.right(), bounds.bottom());
        panel.render(context, mouseX, mouseY, delta);
        context.disableScissor();
    }
    
    /**
     * Renders a REAL 3D preview of the field shape in the GUI.
     * Uses the centralized FieldPreviewRenderer for consistent 3D rendering.
     */
    private void render3DPreview(DrawContext context, Bounds bounds, float delta) {
        // Background for preview area
        context.fill(bounds.x(), bounds.y(), bounds.right(), bounds.bottom(), 0xFF0a0a0a);
        
        // Calculate rotation - use spin if active, otherwise gentle animation
        float time = (System.currentTimeMillis() % 10000) / 10000f * 360f;
        float rotationY = time;
        
        if (state.spin() != null && state.spin().isActive()) {
            float spinSpeed = state.getFloat("spin.speed");
            rotationY = time * spinSpeed / 10f;
        }
        
        // Use selected renderer for 3D preview
        if (useFullPreviewRenderer) {
            // Full/Accurate: Use FieldRenderer (accurate, all features)
            // TODO: Implement proper 3D rendering with FieldRenderer in 2D context
            // For now, fall back to FieldPreviewRenderer
            FieldPreviewRenderer.drawField(context, state, 
                bounds.x(), bounds.y(), bounds.right(), bounds.bottom(),
                1.0f, 25f, rotationY);
        } else {
            // Fast: Use FieldPreviewRenderer (simplified 2D wireframe)
            FieldPreviewRenderer.drawField(context, state, 
                bounds.x(), bounds.y(), bounds.right(), bounds.bottom(),
                1.0f, 25f, rotationY);
        }
        
        // Shape label at bottom
        String shapeType = state.getString("shapeType").toLowerCase();
        String modeLabel = useFullPreviewRenderer ? " (Full)" : "";
        context.drawCenteredTextWithShadow(textRenderer, shapeType + modeLabel, bounds.centerX(), bounds.bottom() - 14, 0xFF666688);
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // INPUT
    // ═══════════════════════════════════════════════════════════════════════════
    
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (activeModal != null && activeModal.isVisible()) return true;
        
        // Handle dropdown scroll
        if (presetDropdown != null && presetDropdown.isExpanded()) {
            if (presetDropdown.handleScroll(mouseX, mouseY, verticalAmount)) {
                return true;
            }
        }
        
        // Use ContentArea for sub-tab scrolling
        if (currentTab != TabType.PROFILES) {
            if (contentArea != null && contentArea.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount)) {
                return true;
            }
        } else {
            if (profilesPanel != null && profilesPanel.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount)) {
                return true;
            }
        }
        
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }
    
    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        // Preset confirmation dialog intercepts clicks first
        if (presetConfirmDialog != null && presetConfirmDialog.isVisible()) {
            return presetConfirmDialog.mouseClicked(mouseX, mouseY, button);
        }
        
        // Modal intercepts all clicks; pass through to its widgets
        if (activeModal != null && activeModal.isVisible()) {
            for (var w : activeModal.getWidgets()) {
                if (w.mouseClicked(mouseX, mouseY, button)) {
                    // CRITICAL: Set screen focus when widget is clicked (for TextFieldWidget)
                    this.setFocused(w);
                    return true;
                }
            }
            // Click outside modal - close it (onClose callback handles cleanup)
            if (!activeModal.containsClick(mouseX, mouseY)) {
                activeModal.hide();
            }
            return true;
        }
        
        // Handle dropdown clicks (expanded dropdown intercepts clicks)
        if (presetDropdown != null && presetDropdown.isExpanded()) {
            if (presetDropdown.handleClick(mouseX, mouseY, button)) {
                return true;
            }
        }
        
        return super.mouseClicked(mouseX, mouseY, button);
    }
    
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        // Preset confirmation dialog intercepts keys first
        if (presetConfirmDialog != null && presetConfirmDialog.isVisible()) {
            return presetConfirmDialog.keyPressed(keyCode, scanCode, modifiers);
        }
        
        // Modal intercepts escape and other keys
        if (activeModal != null && activeModal.isVisible()) {
            // Let focused widget handle key first (critical for TextFieldWidget)
            if (super.keyPressed(keyCode, scanCode, modifiers)) {
                return true;
            }
            // Escape key closes modal (onClose callback handles cleanup)
            if (activeModal.keyPressed(keyCode)) {
                return true;
            }
            return true; // Consume other keys when modal is open
        }
        
        // Escape to close
        if (keyCode == 256) {
            close();
            return true;
        }
        
        // Tab to toggle mode
        if (keyCode == 258) {
            toggleMode();
            return true;
        }
        
        // Ctrl+Z undo
        if (keyCode == 90 && (modifiers & 2) != 0) {
            if (state.canUndo()) {
                state.undo();
                ToastNotification.info("Undo");
                return true;
            }
        }
        
        // Ctrl+Y redo
        if (keyCode == 89 && (modifiers & 2) != 0) {
            if (state.canRedo()) {
                state.redo();
                ToastNotification.info("Redo");
                return true;
            }
        }
        
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    @Override
    public boolean charTyped(char chr, int modifiers) {
        if (presetConfirmDialog != null && presetConfirmDialog.isVisible()) {
            return false; // dialog has no text input
        }
        if (activeModal != null && activeModal.isVisible()) {
            // Let the parent handle charTyped which routes to focused widget
            return super.charTyped(chr, modifiers);
        }
        return super.charTyped(chr, modifiers);
    }
    
    @Override
    public boolean shouldPause() {
        return mode == GuiMode.FULLSCREEN;
    }
    
    @Override
    public void close() {
        // Remove state change listener
        if (stateChangeListener != null) {
            state.removeChangeListener(stateChangeListener);
            stateChangeListener = null;
        }
        
        // Clean up widget visibility registry
        WidgetVisibility.clearAll();
        
        if (state.isDirty()) {
            Logging.GUI.topic("screen").debug("Closing with unsaved changes");
        }
        Logging.GUI.topic("screen").info("FieldCustomizerScreen closed");
        super.close();
    }
}
